<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AssetBundle项目详解]]></title>
    <url>%2F2019%2F04%2F11%2FAssetBundle%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上一章介绍了主要的AssetBundle的基础知识，然而对于一个游戏的热更新而言，Unity提供的方法其实比较难用进项目中。 在项目开发阶段，我们一般会使用路径来进行加载资源，而在AssetBundle加载模式中，我们需要知道资源对应的AssetBundle的名字，相信每一个游戏开发团队都在官方的这些AssetBundle加载API基础上，封装出自己的加载管理类，这几乎是必须的。 在我参考了项目https://github.com/tangzx/ABSystem后，我大概整理了整个热更新AssetBundle框架到底应该如何实现，下面我会通过五个部分来介绍：打包、加载、异步、垃圾回收、路由。 打包Unity5.X以上版本虽然说打包时会处理好资源的依赖关系，但前提依然要我们设置好目标资源的AssetBundleName，如果设置资源AssetBundleName时忽略了资源之间的依赖关系，那么打包AssetBundle时，依然会产生重复打包的资源，所以我们需要实现一套脚本来自动分析资源的依赖关系，并根据资源的依赖关系来设置AssetBundleName，从而避免不必要的资源重复打包。 怎么分析资源的依赖关系呢，并设置AssetBundleName呢？ 我们检测资源之间的依赖关系，遍历每一个有引用的资源进行分析，如果此资源A被其他地方资源B引用仅仅1次，那么就将此资源A的AssetBundleName置空不设置，这样打包时，此资源就会自动被和资源B打到一起合成一个AssetBundle包，如此减少打包的碎片。如果资源A被引用超过2次及以上，那么就为资源独立设置AssetBundleName，从而避免被重复打包到几个依赖它的资源包。这里所说的资源被依赖超过2次就独立打包，如果觉得碎片化太严重，产生太多AssetBundle文件，也可以设置成n（n&gt;=1）次才独立打包。 依赖处理资源依赖处理的代码构建思路： 其实资源之间的依赖关系，就是一个树形依赖关系，只要能构建出资源之间的依赖树，那么就能了解到某个资源被多少颗树引用，也就是被多少个资源引用，从而对症下药，自然能合理设置AssetBundleName。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 //遍历文件夹，设置好需要导出的资源 public void AddRootTargets(DirectoryInfo bundleDir, string[] partterns = null, SearchOption searchOption = SearchOption.AllDirectories) &#123; if (partterns == null) partterns = new string[] &#123; &quot;*.*&quot; &#125;; for (int i = 0; i &lt; partterns.Length; i++) &#123; FileInfo[] prefabs = bundleDir.GetFiles(partterns[i], searchOption); foreach (FileInfo file in prefabs) &#123; if (file.Extension.Contains(&quot;meta&quot;)) continue; AssetTarget target = AssetBundleUtils.Load(file); target.exportType = AssetBundleExportType.Root; &#125; &#125; &#125; //每个资源都是一个AssetTarget，包括被依赖的资源，全部以AssetTarget来作为树的节点 /// &lt;summary&gt; /// AssetTarget中的方法，用于分析引用关系 /// &lt;/summary&gt; public void Analyze() &#123; if (_isAnalyzed) return; _isAnalyzed = true;#if !UNITY_5 LoadMetaHashIfNecessary();#endif _cacheInfo = AssetBundleUtils.GetCacheInfo(assetPath); _isFileChanged = _cacheInfo == null || !_cacheInfo.fileHash.Equals(GetHash()) || !_cacheInfo.metaHash.Equals(_metaHash); if (_cacheInfo != null) &#123; _bundleCrc = _cacheInfo.bundleCrc; if (_isFileChanged) Debug.Log(&quot;File was changed : &quot; + assetPath); &#125; Object[] deps = EditorUtility.CollectDependencies(new Object[] &#123; asset &#125;);#if UNITY_5 || UNITY_2017_1_OR_NEWER List&lt;Object&gt; depList = new List&lt;Object&gt;(); for (int i = 0; i &lt; deps.Length; i++) &#123; Object o = deps[i]; //不包含脚本对象 //不包含LightingDataAsset对象 if (o is MonoScript || o is LightingDataAsset) continue; //不包含builtin对象 string path = AssetDatabase.GetAssetPath(o); if (path.StartsWith(&quot;Resources&quot;)) continue; depList.Add(o); &#125; deps = depList.ToArray();#endif var res = from s in deps let obj = AssetDatabase.GetAssetPath(s) select obj; var paths = res.Distinct().ToArray(); for (int i = 0; i &lt; paths.Length; i++) &#123; if (File.Exists(paths[i]) == false) &#123; //Debug.Log(&quot;invalid:&quot; + paths[i]); continue; &#125; FileInfo fi = new FileInfo(paths[i]); AssetTarget target = AssetBundleUtils.Load(fi); if (target == null) continue; this.AddDependParent(target); target.Analyze(); &#125; &#125; 增量打包在每一次打包时，我们需要记录下上一次打包的信息，Unity没有提供相应的方法，所以我们自己实现一个记录表，在ABsystem中，我们的导出为cache.txt，里面的格式分析如下： 123456789101112130.1.0 //版本号Assets\Prefabs\Capsule.prefab //该资源路径4761b60c435798d357b324a223952d00ea2af8ec //该资源的Hash路径0 //该资源的meta文件的Hash值68e54267c8b7477674d5a4484c5f70e0 //该资源bundle 的CRC值1 //该资源依赖的文件数目Assets\Prefabs\Capsule.mat //该资源依赖的文件路径Assets\Prefabs\Cube.prefab480e961c688db3d18f38ea58b4a868813fc67ac904d19c1f22dee83dd90b56704af0d42941Assets\Prefabs\New Folder\Cube.mat 在每一次打包的时候，先遍历这个文件，然后分析变化的资源和新增的资源。 路径对应表我们希望通过路径直接加载物品，所以需要记录下来一个路径和assetbundlename 的对应表，项目中的表为dep.all： 1234567891011121314151617ABDT //文件格式Assets\Prefabs\Capsule.prefab //路径a4833bddf07044b10907d4c7a27ab216a6be022e.ab //对应的assetbundlenamecapsule.prefab //短名68e54267c8b7477674d5a4484c5f70e0 //bundleCrc2 //资源类型： 1为被依赖的资源 2 为根资源 3为既是根又是被别人依赖的素材 4为需要单独打包，说明这个素材是被两个或以上的素材依赖的 1 //依赖的资源个数32c04e3e5d22ce244261a5b10216ab07ac90a79b.ab //依赖资源的assetbundlename&lt;-------------&gt;Assets\Prefabs\Cube.prefab3a85b78f45e66d3862c78b03de9e64e228bedc8c.abcube.prefab4d19c1f22dee83dd90b56704af0d4294213cad3b04a9322d382ebad4c86213a84f90d9d7f9.ab&lt;-------------&gt; 路由路由——管理资源加载的路径 Unity是一个跨平台的游戏引擎，每一个平台都会有它特殊的处理资源的路径方式，在Unity中一般我们常见的是StreamingAssets和PersistentDataPath两种路径。 可是这里面，也隐含有不少的坑，比如说，在windows平台里面，路径URL，斜杠必须得3个///。安卓平台下，StreamingAssets目录是不能同步读取的（APK内目录），但是包括iOS在内的其他所有平台都是可以通过同步File.ReadAllBytes读取的。 不仅如此，由于Asset Bundle的打包是平台定向性的：打出Android的Asset Bundle，不能再iOS下使用；反之亦然。因此，AssetBundleLoader加载器在实际运行时，需要一个路由管理器来告诉它什么样的平台，使用哪里的AssetBundle目录。我把这叫作“路由”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112using System.IO;using UnityEngine;namespace Tangzx.ABSystem&#123; /// &lt;summary&gt; /// AB 打包及运行时路径解决器 /// &lt;/summary&gt; public class AssetBundlePathResolver &#123; public static AssetBundlePathResolver instance; public AssetBundlePathResolver() &#123; instance = this; &#125; /// &lt;summary&gt; /// AB 保存的路径相对于 Assets/StreamingAssets 的名字 /// &lt;/summary&gt; public virtual string BundleSaveDirName &#123; get &#123; return &quot;AssetBundles&quot;; &#125; &#125;#if UNITY_EDITOR /// &lt;summary&gt; /// AB 保存的路径 /// &lt;/summary&gt; public string BundleSavePath &#123; get &#123; return &quot;Assets/StreamingAssets/&quot; + BundleSaveDirName; &#125; &#125; /// &lt;summary&gt; /// AB打包的原文件HashCode要保存到的路径，下次可供增量打包 /// &lt;/summary&gt; public virtual string HashCacheSaveFile &#123; get &#123; return &quot;Assets/AssetBundles/cache.txt&quot;; &#125; &#125; /// &lt;summary&gt; /// 在编辑器模型下将 abName 转为 Assets/... 路径 /// 这样就可以不用打包直接用了 /// &lt;/summary&gt; /// &lt;param name=&quot;abName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public virtual string GetEditorModePath(string abName) &#123; //将 Assets.AA.BB.prefab 转为 Assets/AA/BB.prefab abName = abName.Replace(&quot;.&quot;, &quot;/&quot;); int last = abName.LastIndexOf(&quot;/&quot;); if (last == -1) return abName; string path = string.Format(&quot;&#123;0&#125;.&#123;1&#125;&quot;, abName.Substring(0, last), abName.Substring(last + 1)); return path; &#125;#endif /// &lt;summary&gt; /// 获取 AB 源文件路径（打包进安装包的） /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;forWWW&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public virtual string GetBundleSourceFile(string path, bool forWWW = true) &#123; string filePath = null;#if UNITY_EDITOR if (forWWW) filePath = string.Format(&quot;file://&#123;0&#125;/StreamingAssets/&#123;1&#125;/&#123;2&#125;&quot;, Application.dataPath, BundleSaveDirName, path); else filePath = string.Format(&quot;&#123;0&#125;/StreamingAssets/&#123;1&#125;/&#123;2&#125;&quot;, Application.dataPath, BundleSaveDirName, path);#elif UNITY_ANDROID if (forWWW) filePath = string.Format(&quot;jar:file://&#123;0&#125;!/assets/&#123;1&#125;/&#123;2&#125;&quot;, Application.dataPath, BundleSaveDirName, path); else filePath = string.Format(&quot;&#123;0&#125;!assets/&#123;1&#125;/&#123;2&#125;&quot;, Application.dataPath, BundleSaveDirName, path);#elif UNITY_IOS if (forWWW) filePath = string.Format(&quot;file://&#123;0&#125;/Raw/&#123;1&#125;/&#123;2&#125;&quot;, Application.dataPath, BundleSaveDirName, path); else filePath = string.Format(&quot;&#123;0&#125;/Raw/&#123;1&#125;/&#123;2&#125;&quot;, Application.dataPath, BundleSaveDirName, path);#else throw new System.NotImplementedException();#endif return filePath; &#125; /// &lt;summary&gt; /// AB 依赖信息文件名 /// &lt;/summary&gt; public virtual string DependFileName &#123; get &#123; return &quot;dep.all&quot;; &#125; &#125; DirectoryInfo cacheDir; /// &lt;summary&gt; /// 用于缓存AB的目录，要求可写 /// &lt;/summary&gt; public virtual string BundleCacheDir &#123; get &#123; if (cacheDir == null) &#123;#if UNITY_EDITOR string dir = string.Format(&quot;&#123;0&#125;/&#123;1&#125;&quot;, Application.streamingAssetsPath, BundleSaveDirName);#else string dir = string.Format(&quot;&#123;0&#125;/AssetBundles&quot;, Application.persistentDataPath);#endif cacheDir = new DirectoryInfo(dir); if (!cacheDir.Exists) cacheDir.Create(); &#125; return cacheDir.FullName; &#125; &#125; &#125;&#125; 加载AssetBundle加载资源的API非常的简单，核心其实只是两个函数，一个同步和一个异步。 // 同步加载，直接返回AssetBundle AssetBundle.LoadFromFile(path);// 异步加载，返回AssetBundleCreateRequest AssetBundle.LoadFromFileAsync(path); 在Unity的标准Asset Bundle加载接口中，同步加载返回了行为结果，异步加载则返回了行为追踪对象。具体来说，同步加载，直接就返回了资源的AssetBundle；异步加载，则返回了异步加载的追踪对象AssetBundleCreateRequest。追踪对象，用于之后进行资源异步加载情况跟踪，被协程轮询判断是否已经异步加载完毕，若完成了可从追踪对象里获取加载资源。 由于同步和异步的加载API不一样，在项目实际应用时，往往没有统一的加载接口。要避免这种情况，可以统一加载行为，都返回追踪对象。加载器在ABSystem中被封装为AssetBundleLoader,对象为AssetBundleInfo。 123456789101112131415161718192021222324252627282930313233343536using UnityEngine;using Tangzx.ABSystem;public class Test : MonoBehaviour&#123; AssetBundleManager manager; void Start() &#123; manager = gameObject.AddComponent&lt;AssetBundleManager&gt;(); manager.Init(() =&gt; &#123; LoadObjects(); &#125;); &#125; void LoadObjects() &#123; manager.Load(&quot;Assets.Prefabs.Sphere.prefab&quot;, (a) =&gt; &#123; GameObject go = Instantiate(a.mainObject) as GameObject;//a.Instantiate(); go.transform.localPosition = new Vector3(3, 3, 3); &#125;); //manager.Load(&quot;Assets.Prefabs.Sphere.prefab&quot;, (a) =&gt; //&#123; // GameObject go = a.Instantiate(); // go.transform.localPosition = new Vector3(6, 3, 3); //&#125;); //manager.Load(&quot;Assets.Prefabs.Plane22.prefab&quot;, (a) =&gt; //&#123; // GameObject go = a.Instantiate(); // go.transform.localPosition = new Vector3(6, 3, 3); //&#125;); &#125;&#125; 资源的释放如要对加载Loader追踪对象进行引用计数递减，可以调用每个Loader里的Release函数： 当一个Loader的引用计数为0时，它就会进入到释放队列，待几秒后释放。 项目中每5秒执行一次CheckUnusedBundle方法来检测是否有无用的assetbundle，而项目中的检测用WeakReference来关联资源的创建和销毁检测。 延迟清理当一个加载对象被引用计数减为0的时候，他不会被立刻释放。因为存在这样一种场景：当引用变成0的同一时间，同样的资源又被创建一份新的，引用计数立刻变回1。所以如果说当他引用计数为0时候，立刻就被清理了，同时又被创建，这里，就会造成了重复的对这份内存资源创建和释放。项目中的AssetBundleManager定义了很多List来做这些判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 internal void LoadComplete(AssetBundleLoader loader) &#123; _requestRemain++; _currentLoadQueue.Remove(loader); if (onProgress != null) &#123; _progress.loader = loader; _progress.complete = _progress.total - _currentLoadQueue.Count; onProgress(_progress); &#125; //all complete if (_currentLoadQueue.Count == 0 &amp;&amp; _nonCompleteLoaderSet.Count == 0) &#123; _isCurrentLoading = false; var e = _thisTimeLoaderSet.GetEnumerator(); while (e.MoveNext()) &#123; AssetBundleLoader cur = e.Current; if (cur.bundleInfo != null) cur.bundleInfo.ResetLifeTime(); //加载完成资源后，将当前的time赋值给bundleInfo中的lifetime。 &#125; _thisTimeLoaderSet.Clear(); &#125; &#125; void CheckUnusedBundle() &#123; this.UnloadUnusedBundle(); &#125; /// &lt;summary&gt; /// 卸载不用的 /// &lt;/summary&gt; public void UnloadUnusedBundle(bool force = false) &#123; if (_isCurrentLoading == false || force) &#123; List&lt;string&gt; keys = ListPool&lt;string&gt;.Get(); keys.AddRange(_loadedAssetBundle.Keys); bool hasUnusedBundle = false; //一次最多卸载的个数，防止卸载过多太卡 int unloadLimit = 20; int unloadCount = 0; do &#123; hasUnusedBundle = false; for (int i = 0; i &lt; keys.Count &amp;&amp; !_isCurrentLoading &amp;&amp; unloadCount &lt; unloadLimit; i++) &#123; if (_isCurrentLoading &amp;&amp; !force) break; string key = keys[i]; AssetBundleInfo abi = _loadedAssetBundle[key]; if (abi.isUnused) //判断是否销毁的时候，检测lifetime和weakReference &#123; hasUnusedBundle = true; unloadCount++; this.RemoveBundleInfo(abi); keys.RemoveAt(i); i--; &#125; &#125; &#125; while (hasUnusedBundle &amp;&amp; !_isCurrentLoading &amp;&amp; unloadCount &lt; unloadLimit); ListPool&lt;string&gt;.Release(keys);#if UNITY_EDITOR if (unloadCount &gt; 0 &amp;&amp; enableLog) &#123; Debug.Log(&quot;===&gt;&gt; Unload Count: &quot; + unloadCount); &#125;#endif &#125; &#125; 热更新策略 本文参考：https://gameinstitute.qq.com/community/detail/120375 https://blog.csdn.net/u012740992/article/details/79371986]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AssetBundle入门解析]]></title>
    <url>%2F2019%2F04%2F08%2FAssetBundle%E5%85%A5%E9%97%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一个开头快速功能迭代开发的游戏，直到中后期才萌生热更新的需求，而在Unity里做资源热更（AssetBundle）和代码热更（Lua）是一个不小的工作，需要耗费相当多的精力。怎么办？。 相信大家对于游戏的热更新都有了一定的概念，但是AssetBundle究竟是什么东西？和Resource的加载方式有什么不一样呢？ 介绍AssetBundles是Unity编辑器中在编辑过程中创建的一些文件，这些文件可以在项目运行环境中使用。AssetBundles可以包含的资源文件比如模型，材质，贴图和场景等等，注意：AssetBundles不能包含脚本! 具体来说，一个AssetBundle就是把资源或者场景以某种方式紧密集合在一起的一个文件。这个AssetBundle文件可以被单独加载到unity应用程序中。这允许模型、贴图、音效设置很大的场景这些资源进行流式加载或者异步加载。当然AssetBundle文件也可以本地缓存这样能够在程序启动的时候立马被加载出来。但AssetBundle技术主要目的就是需要的时候从远程服务器下载需要的资源。AssetBundle可以包含任何unity可识别的资源文件，甚至包括二进制文件。但就是不能包含脚本文件。 在Resource模式中，开发者是几乎完全不用操心他们的资源管理的技术细节。直接使用编辑器进行资源编辑，用完以后开发完以后直接打包最终程序就可以了。而Asset Bundle模式则需要自己进行资源的打包加载管理。在AssetBundle模式和Resource相比较之下，这个模式看上去就像后来迭代版本的时候加出来的一个功能——基于原有Resource模式的不足，提供一个对资源方式更自由控制的方式。 AssetBundle允许从本地或者远程服务器加载Assets资源，利用AssetBundle技术，Assets资源可以放在远程服务器上，这种技术增加了项目灵活性并且减少项目初始包的大小。 本文介绍AssetBundles并且讨论一步一步的介绍怎么样使用它，怎样将资源打包到AssetBundle中，如何通过AssetBundle来加载资源到游戏中。 AssetBundle资源打包创建工程和资源首先我们创建一个新工程并在里面创建出一个Material和Prefab资源，让Prefab资源引用Material。整个项目的结构如图： 编写脚本在Unity中打AssetBundle包很简单，只需要调用 BuildPipeline.BuildAssetBundles 方法就好了，但是要为想要导出的资源设置好 assetBundleName ，如果该资源没有被设置 assetBundleName，而且没有被设置了 assetBundleName 的资源所引用，那么Unity就不会打包该资源。那么如何在项目中设置 assetBundleName 呢？ 首先在Project目录中选中想要导出的资源，在Inspector的最底下有个展示框，如果没有的话点住图中的label往上拉就可以看见了，如图中的前一格就是我们的 assetBundleName ，后面一格是我们的Asset Bundle Variant，目前不做介绍，先不设置，我们按图中的设置把Material和Prefab都设置assetBundleName为test。 BuildPipeline.BuildAssetBundles 有两种重载，我将会在代码中介绍他们的区别。创建BuildAssetBundlesExample，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Create an AssetBundle for Windows.using UnityEngine;using UnityEditor;using System.IO;#if UNITY_EDITOR //若脚本文件不在Editor目录下，则需要判断，否则会报错public class BuildAssetBundlesExample : MonoBehaviour&#123; [MenuItem(&quot;Example/Build Asset Bundle&quot;)] static void BuildABs() &#123; var path = &quot;Assets/ABs&quot;; Debug.Log(&quot;启动所有的打包&quot;); //简易打包法，将当前项目中所有设置了assetBundleName 的或者被引用的资源都打包到对应路径。 // BuildTarget用来控制对应的平台，每个平台的assetbundle不能通用，所以每个平台的包都要重新打，这边为了方便在电脑上测试我们设置成StandaloneWindows。 //BuildAssetBundleOptions控制压缩，主要是三种，None默认使用LZMA //1.LZMA : 压缩厉害，但是每次访问都要全部解压，比如我只需要访问该assetbundle的某个prefab，但是却需要等整个assetbundle的资源解压完毕，访问速度慢。 //2.LZ4 ： 压缩比LZMA差一点，但是只需要解压我们需要访问的资源，访问速度比LZMA快。 //3. 不压缩。 // Put the bundles in a folder called &quot;ABs&quot; within the Assets folder. if (!Directory.Exists(path)) &#123; Directory.CreateDirectory(path); &#125; BuildPipeline.BuildAssetBundles(path, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows); &#125; [MenuItem(&quot;Example/Build Asset Bundles Using BuildMap&quot;)] static void BuildMapABs() &#123; //像第一种，我们必须要给每个资源精细设置assetBundleName，然而在整个项目很大的情况下，你肯定希望用脚本来控制这一些资源，这时候就可以使用第二种重载的方式 // Create the array of bundle build details. AssetBundleBuild[] buildMap = new AssetBundleBuild[2]; buildMap[0].assetBundleName = &quot;prefabbundle&quot;; string[] prefabAssets = new string[2]; prefabAssets[0] = &quot;Assets/Prefabs/Cube.prefab&quot;; buildMap[0].assetNames = prefabAssets; buildMap[1].assetBundleName = &quot;materialbundle&quot;; string[] materialAssets = new string[1]; materialAssets[0] = &quot;Assets/Materials/New Material.mat&quot;; buildMap[1].assetNames = materialAssets; var path = &quot;Assets/ABsBuildMap&quot;; // Put the bundles in a folder called &quot;ABs&quot; within the Assets folder. if (!Directory.Exists(path)) &#123; Directory.CreateDirectory(path); &#125; BuildPipeline.BuildAssetBundles(path, buildMap, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows); &#125;&#125;#endif 当你创建了这个脚本后，你就可以通过项目中的Example下的选项来使用两种方法导出项目的资源了。 导出的资源分析我们查看下第一种方式打包出来的assetbundle的资源。可以看到我们在Assets/ABs下有了四个文件。 我们可以注意到目录下有两个和文件夹名字一样的文件，打开ABs.manifest查看下信息。 12345678// ABs.manifestManifestFileVersion: 0CRC: 3628773453AssetBundleManifest: AssetBundleInfos: Info_0: Name: test Dependencies: &#123;&#125; 该文件为整个目录下的所有assetbundle的记录，它记录了每个assetbundle间的依赖情况和整个文件夹下的所有的assetbundle的信息，我们后面可以通过它来查找所需要加载的依赖。 1234567891011121314151617181920212223242526272829303132// test.manifestManifestFileVersion: 0CRC: 1635728007Hashes: AssetFileHash: serializedVersion: 2 Hash: 48e66a94b791e3c542d971998c32fe2d TypeTreeHash: serializedVersion: 2 Hash: ea3f786f3814b1ad9ef2ef747825eec5HashAppended: 0ClassTypes:- Class: 1 Script: &#123;instanceID: 0&#125;- Class: 4 Script: &#123;instanceID: 0&#125;- Class: 21 Script: &#123;instanceID: 0&#125;- Class: 23 Script: &#123;instanceID: 0&#125;- Class: 33 Script: &#123;instanceID: 0&#125;- Class: 43 Script: &#123;instanceID: 0&#125;- Class: 48 Script: &#123;instanceID: 0&#125;- Class: 65 Script: &#123;instanceID: 0&#125;Assets:- Assets/Prefabs/Cube.prefab- Assets/Materials/New Material.matDependencies: [] test.manifest下记录了该assetbundle下的所有asset和该assetbundle的依赖情况 加载资源资源都在一个 assetbundle比如第一种打包情况，我们将prefab和它所依赖的material都打包到test这个AssetBundle中，那么我们加载的时候就只需要加载这个assetbundle就好了，加载方式如下： 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class LoadAssetBundle : MonoBehaviour&#123; // Start is called before the first frame update void Start() &#123; //从test包中加载 AssetBundle prefabAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABs&quot;, &quot;test&quot;)); if (prefabAssetBundle == null) &#123; Debug.Log(&quot;Failed to load AssetBundle!&quot;); return; &#125; var prefab = prefabAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); Instantiate(prefab); prefabAssetBundle.Unload(false); //释放掉assetbundle，false表示释放掉prefabAssetBundle但是不回收场景里面的对应的资源，那么留在场景里的资源就要自己手动释放。true表示释放掉prefabAssetBundle并回收场景里面的对应的资源，一般在切换场景之类的时候使用，要小心使用。 ｝｝ 资源都不在同一个 assetbundle第二种打包情况中我们把prefab分到了prefabbundle这个包中，然后它所引用的material则分到了materialbundle包中，所以我们加载的时候需要加载两个包。 12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class LoadAssetBundle : MonoBehaviour&#123; // Start is called before the first frame update void Start() &#123; //当material和prefab分开在不同的包中加载 //如果不加载materialbundle，实例化出来的prefab会丢失材质 var matAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, &quot;materialbundle&quot;)); var prefabAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, &quot;prefabbundle&quot;)); if (prefabAssetBundle == null) &#123; Debug.Log(&quot;Failed to load prefabAssetBundle!&quot;); return; &#125; if (matAssetBundle == null) &#123; Debug.Log(&quot;Failed to load matAssetBundle!&quot;); return; &#125; var prefab2 = prefabAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); Instantiate(prefab2); prefabAssetBundle.Unload(false); matAssetBundle.Unload(false); ｝｝ 我们也可以通过包的主文件来动态查询我们的依赖包的包名，并进行加载，代码如下： 12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class LoadAssetBundle : MonoBehaviour&#123; // Start is called before the first frame update void Start() &#123; //当material和prefab分开在不同的包中加载,通过包查找依赖 //加载主要的AssetBundleManifest AssetBundle mainAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, &quot;ABsBuildMap&quot;)); AssetBundleManifest manifest = mainAssetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;); var prefabAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, &quot;prefabbundle&quot;)); //foreach (var name in manifest.GetAllAssetBundles()) //遍历所有的AssetBundle的名字 //&#123; // print(name); //&#125; var dependsAssetBundle = new List&lt;AssetBundle&gt;(manifest.GetAllDependencies(&quot;prefabbundle&quot;).Length); foreach (var name in manifest.GetAllDependencies(&quot;prefabbundle&quot;)) //遍历prefabbundle包所有的依赖的AssetBundle的名字 &#123; dependsAssetBundle.Add(AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, name))); //加载所有的依赖包 &#125; var prefab2 = prefabAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); Instantiate(prefab2); ｝｝ 加载服务器上的assetbundle热更新中我们一般会把assetbundle部署到服务器上，Unity为我们封装了UnityWebRequest来加载。 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class LoadAssetBundle : MonoBehaviour&#123; // Start is called before the first frame update IEnumerator Start() &#123; //--------- string url = @&quot;file:///E:\UnityProject\AssetBundleTest\Assets\ABs\test&quot;; //假设为服务端地址 UnityWebRequest uwr = UnityWebRequestAssetBundle.GetAssetBundle(url); yield return uwr.SendWebRequest(); //Get an asset from the bundle and instantiate it. AssetBundle myLoadedAssetBundle = DownloadHandlerAssetBundle.GetContent(uwr); var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Assets/Prefabs/Cube.prefab&quot;); //var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); Instantiate(prefab); myLoadedAssetBundle.Unload(false); ｝｝ 以上就是主要的入门知识了，大家可以发现整个AssetBundle目前的方法其实是不全的，想要做到热更新的话我们还需要版本对比，然后我们最好能够手写一个资源回收方法来控制AssetBundle的Unload操作，这些我会放在下一章开始讲，当然Unity本身也有很多其它的可以异步的加载方式，比如LoadFromMemoryAsync之类的，大体都一样，可以自己去查看官方文档。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaskField检测选项]]></title>
    <url>%2F2019%2F04%2F02%2FMaskField%E6%A3%80%E6%B5%8B%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[今天在编写工具时发现了一个有趣的Unity方法叫MaskField.但是在查看原文档的时候发现没有如何判断自己选了哪几个选项的方法，所以自己通过试验写了个判定的方法。 MaskField12345678910111213141516171819202122232425262728293031using UnityEngine;using UnityEditor;public class MaskFieldExample : EditorWindow&#123; static int flags = 0; static string[] options = new string[] &#123;&quot;CanJump&quot;, &quot;CanShoot&quot;, &quot;CanSwim&quot;&#125;; [MenuItem(&quot;Examples/Mask Field usage&quot;)] static void Init() &#123; MaskFieldExample window = (MaskFieldExample)GetWindow(typeof(MaskFieldExample)); window.Show(); &#125; void OnGUI() &#123; flags = EditorGUILayout.MaskField(&quot;Player Flags&quot;, flags, options); if (GUILayout.Button(&quot;Log options&quot;)) &#123; for (int i = 0; i &lt; options.Length; i++) &#123; if ((flags &amp; 1 &lt;&lt; i) != 0) &#123; Debug.Log(options[i]); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity世界坐标和本地坐标的转换]]></title>
    <url>%2F2019%2F03%2F14%2FUnity%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[游戏开发过程中，我们经常需要用到本地坐标和世界坐标的转换，尤其是配置位置偏移的时候，例如你希望在某个怪物的左前方放置特效，则需要在怪物的坐标系中做转换。 首先，世界坐标是指物体在场景中的坐标，当某个物体没有父物体时，它的position即为世界坐标的position，rotation同理；本地坐标是物体相对于它的父物体的坐标而言（ 父物体又套父物体的我还没有研究），这个相对坐标是以父物体本身为坐标轴进行计算的，与世界坐标没有必然联系。而对于没有父物体的物体，可以认为不存在本地坐标这种说法。另外有一点需要注意：当某个物体有父物体时，它的inspector栏transform中的position实际是localposition，即本地坐标。 在Unity中提供了很多原生的方法来做坐标转换，所以我们可以直接调用它们的方法来达到我们的目的，所以本文主要为了代码的简化而编写。 Unity原生方法转换 TransformPoint 偏移法TransformPoint 将坐标从本地坐标转到世界坐标,worldPos3为核心用法，将当前本地坐标系中的偏移转到世界坐标系中。 12345678910public Transform myParent; //该物体的父元素// Start is called before the first frame updatevoid Start()&#123; var localPos = transform.localPosition; //本地坐标 var worldPos = transform.position; //transform.position获取到的是世界坐标 var worldPos2 = transform.TransformPoint(Vector3.zero); var worldPos3 = myParent.transform.TransformPoint(localPos); Debug.Log(&quot;localPos:&quot; +localPos+&quot;worldPos:&quot;+worldPos+&quot;worldPos2:&quot;+worldPos2+&quot;worldPos3:&quot;+worldPos3);&#125; 偏移法通过使用四元数乘于偏移的向量来获得旋转后的偏移向量。 1234567public Transform myParent; //该物体的父元素// Start is called before the first frame updatevoid Start()&#123; var localPos = transform.localPosition; //本地坐标 var worldPos4 = myParent.transform.position + myParent.transform.rotation * localPos;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Unity的TreeView来编写一个显示目录和文件的树形菜单]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%A9%E7%94%A8Unity%E7%9A%84TreeView%E6%9D%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[最近在编写unity的工具，碰见需要将工程中某个文件夹下的playable文件遍历出来让人选取，然后再进行操作，所以正好去了解了一下Unity中TreeView的用法，发现真的是很方便，所以做了个方便拓展的专门用于遍历目录文件的TreeView。 你们可以在工程中添加下面两个文件，然后在菜单栏中选中TreeView Examples/File Tree Window就可以查看效果。 FloderFileTreeView.cs首先是TreeView文件FloderFileTreeView.cs，里面包含了继承于TreeViewItem的FolderTreeViewItem，和继承于TreeView的FloderFileTreeView，FolderTreeViewItem中可以添加自己所需要的属性，这样可以在选取的时候做一些操作。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System.Collections.Generic;using System.IO;using UnityEditor.IMGUI.Controls;using UnityEngine;namespace UnityEditor.TreeViewExample&#123; class FloderFileTreeView : TreeView &#123; public FloderFileTreeView(TreeViewState treeViewState) : base(treeViewState) &#123; Reload(); &#125; protected override TreeViewItem BuildRoot () &#123; var root = new TreeViewItem &#123;id = 0, depth = -1, displayName = &quot;Root&quot;&#125;; TraceTree(root,Application.dataPath); return root; &#125; public void TraceTree(TreeViewItem item,string path) &#123; DirectoryInfo theFolder = new DirectoryInfo(path); DirectoryInfo[] dirInfo = theFolder.GetDirectories(); var files = theFolder.GetFiles(&quot;*.*&quot;,SearchOption.TopDirectoryOnly); if (dirInfo.Length &gt; 0) &#123; foreach (DirectoryInfo NextFolder in dirInfo) &#123; FolderTreeViewItem fItem = new FolderTreeViewItem( NextFolder.GetHashCode(), item.depth + 1, NextFolder.Name); item.AddChild(fItem); TraceTree(fItem,path + &quot;/&quot; + NextFolder.Name); &#125; &#125; foreach (var file in files) &#123; FolderTreeViewItem fItem = new FolderTreeViewItem( file.GetHashCode(), item.depth + 1, file.Name); item.AddChild(fItem); &#125; &#125; // protected override void RowGUI (RowGUIArgs args) // &#123; // &#125; protected override void SelectionChanged(IList&lt;int&gt; selectedIds) &#123; base.SelectionChanged(selectedIds); var item = FindItem(selectedIds[0],rootItem) as FolderTreeViewItem; Debug.Log(item.aPath.ToString()); &#125; &#125; public class FolderTreeViewItem : TreeViewItem &#123; public string aPath; public FolderTreeViewItem(int id,int depth,string displayName):base(id,depth,displayName)&#123; aPath = displayName; &#125; &#125;&#125; FloderFileTreeViewWindow.cs窗口用于显示TreeView，其中SearchField用于创建一个搜索框，也是自带的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using UnityEngine;using UnityEditor.IMGUI.Controls;namespace UnityEditor.TreeViewExample&#123; class FloderFileTreeViewWindow : EditorWindow &#123; // We are using SerializeField here to make sure view state is written to the window // layout file. This means that the state survives restarting Unity as long as the window // is not closed. If omitting the attribute then the state just survives assembly reloading // (i.e. it still gets serialized/deserialized) [SerializeField] TreeViewState m_TreeViewState; // The TreeView is not serializable it should be reconstructed from the tree data. FloderFileTreeView m_TreeView; SearchField m_SearchField; void OnEnable () &#123; // Check if we already had a serialized view state (state // that survived assembly reloading) if (m_TreeViewState == null) m_TreeViewState = new TreeViewState (); m_TreeView = new FloderFileTreeView(m_TreeViewState); m_SearchField = new SearchField (); m_SearchField.downOrUpArrowKeyPressed += m_TreeView.SetFocusAndEnsureSelectedItem; &#125; void OnGUI () &#123; DoToolbar (); DoTreeView (); &#125; void DoToolbar() &#123; GUILayout.BeginHorizontal (EditorStyles.toolbar); GUILayout.Space (100); GUILayout.FlexibleSpace(); m_TreeView.searchString = m_SearchField.OnToolbarGUI (m_TreeView.searchString); GUILayout.EndHorizontal(); &#125; void DoTreeView() &#123; var r = EditorGUILayout.GetControlRect(false,303); m_TreeView.OnGUI(r); //m_TreeView.ExpandAll(); &#125; // Add menu named &quot;My Window&quot; to the Window menu [MenuItem (&quot;TreeView Examples/File Tree Window&quot;)] static void ShowWindow () &#123; // Get existing open window or if none, make a new one: var window = GetWindow&lt;FloderFileTreeViewWindow&gt; (); window.titleContent = new GUIContent (&quot;My Window&quot;); window.Show (); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>TreeView</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator 全局监听事件]]></title>
    <url>%2F2018%2F09%2F29%2FCocos-Creator-%E5%85%A8%E5%B1%80%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[全局事件系统Cocos Creator中最近要用全局事件派送，奈何官方虽然提供了this.node.emit，但是只能监听同一个节点的事件，不可以实现监听其它节点发出的事件，也就是全局事件，所以自己找了两种方法解决。 cc.EventTarget让所有节点统一在同一个全局对象上触发和监听事件这个全局对象可以是全局节点，也可以是 window.GlobalEvent = new cc.EventTarget(); 1234567891011121314//监听 onLoad() &#123; GlobalEvent.on(&quot;Test&quot;, function (event) &#123; console.log(&quot;Test&quot;, event.detail); &#125;); GlobalEvent.on(&quot;Test&quot;, this.showLog); &#125;, showLog(event) &#123; console.log(&quot;eat&quot;, event.detail); &#125;,//传递事件 GlobalEvent.emit(&quot;Test&quot;, &quot;see you tomorrow&quot;); 插件脚本通过设置一个插件脚本或者全局变量的Notifacation来统一处理事件的监听和分发。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var NOTIFICATION = (function ()&#123; var eventList = &#123;&#125;; function on(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;on&apos; param error!&quot;); return; &#125; if (typeof eventList[type] === &quot;undefined&quot;) &#123; eventList[type] = []; &#125; eventList[type].push(&#123;callback: callback, target: target&#125;); &#125; function once(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;on&apos; param error!&quot;); return; &#125; if (typeof eventList[type] === &quot;undefined&quot;) &#123; eventList[type] = []; &#125; eventList[type].push(&#123;callback: callback, target: target, once: true&#125;); &#125; function emit(type, data) &#123; if (typeof type !== &quot;string&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;emit&apos; param error!&quot;); return; &#125; var list = eventList[type]; if (typeof list !== &quot;undefined&quot;) &#123; for (var i = 0; i &lt; list.length; i++) &#123; var event = list[i]; if (event) &#123; event.callback.call(event.target, data); if(event.once)&#123; off(type, event.callback, event.target); &#125; &#125; &#125; &#125; &#125; function off(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;off&apos; param error!&quot;); return; &#125; var list = eventList[type]; if (typeof list !== &quot;undefined&quot;) &#123; for (var i = 0; i &lt; list.length; i++) &#123; var event = list[i]; if (event &amp;&amp; event.callback === callback &amp;&amp; event.target === target) &#123; list.splice(i, 1); break; &#125; &#125; &#125; &#125; function offByType(type) &#123; if (typeof type !== &quot;string&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;offByType&apos; param error!&quot;); return; &#125; while (eventList[type].length &gt; 1) &#123; eventList[type].shift(); &#125; eventList[type] = undefined; &#125; function offByTarget(target)&#123; if (typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;offByTarget&apos; param error!&quot;); return; &#125; for(var key in eventList)&#123; for(var i = 0; i &lt; eventList[key].length ; i++)&#123; if(eventList[key][i].target === target)&#123; eventList[key].splice(i, 1); cc.log(&apos;off &apos; + key); break; &#125; &#125; &#125; &#125; return &#123;on: on, once: once, emit: emit, off: off, offByType: offByType, offByTarget: offByTarget&#125;;&#125;)();]]></content>
      <tags>
        <tag>Cocos Creator</tag>
        <tag>观察者模式</tag>
        <tag>全局事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator 单例模式]]></title>
    <url>%2F2018%2F09%2F29%2FCocos-Creator-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例，在游戏开发中是比较常用的功能，全局唯一，可以在任何地方直接获取, 省去了方法赋值 或者 属性面板拖动的麻烦。 在Cocos Creator中我用于创建NetwrokManager来控制联网管理，在该单例中处理所有的服务器监听，然后通过观察者模式通知相应的监听事件来处理客户端逻辑。 普通单例 饿汉模式 饱汉模式饿汉模式 不管有没调用，一开始就创建单例 12345678910111213141516171819202122// Singleton.js var Singleton = cc.Class(&#123; // 成员变量 name : "", age : 0, ctor () &#123; this.name = "Leovany"; this.age = 20; &#125;, statics: &#123; _instance: null &#125;, printInfo()&#123; cc.warn("name = " + this.name+",age = " + this.age); &#125;&#125;);Singleton._instance = new Singleton();module.exports = Singleton; 12345678// GameManager.js// 引入单例类var Singleton = require("Singleton");var GameManager = cc.Class(&#123; cc.warn(Singleton._instance.name); Singleton._instance.printInfo();&#125;); 饱汉模式调用时才创建单例对象 1234567891011121314151617181920212223242526// Singleton.js var Singleton = cc.Class(&#123; // 成员变量 name : "", age : 0, ctor () &#123; this.name = "Leovany"; this.age = 20; &#125;, printInfo()&#123; cc.warn("name = " + this.name+",age = " + this.age); &#125;&#125;);Singleton._instance = null;Singleton.getInstance = function () &#123; if(!Singleton._instance)&#123; Singleton._instance = new Singleton(); &#125; return Singleton._instance;&#125;module.exports = Singleton; 12345678// GameManager.js// 引入单例类var Singleton = require("Singleton");var GameManager = cc.Class(&#123; cc.warn(Singleton._instance.name); Singleton._instance.printInfo();&#125;); 单例组件通过创建单例节点，并设置为常驻节点，来保证切换场景时不被摧毁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 开头必须 新建一个变量引用 var NetworkManagervar NetworkManager = cc.Class(&#123; extends: cc.Component, editor: &#123; executionOrder: -1 &#125;, properties: &#123; _userid: 0, _socket: null, _connected: false, DEFAULT_NETWORK_IP: &#123; get() &#123; return "http://123.1.1.1:5000"; &#125;, &#125;, &#125;, statics: &#123; _instance: null &#125;, //最先进入地方 onLoad() &#123; cc.warn(" ============== NetworkManager init"); NetworkManager._instance = this; if (cc.sys.isNative) &#123; window.io = SocketIO; &#125; let self = this; this._socket = window.io(this.DEFAULT_NETWORK_IP); //进行所有数据的监听和存储 this._socket.on('WC_CONNECTED', function (data) &#123; cc.log("now you see WC_CONNECTED"); self._connected = true; &#125;); this._socket.on('WC_LOGIN_RESPONSE', function (data) &#123; // 返回的一些数据 Notification.emit("WC_LOGIN_RESPONSE", data); // 通知客户端监听节点，Notification是一个自己编写的全局的观察者模式。 cc.log("WC_LOGIN_RESPONSE"); cc.log(data); if (data.error_id == 0) &#123; cc.log("login success!"); self.player = data.player; &#125; else &#123; cc.log("login fail!"); &#125; &#125;); //设置帧率 cc.game.setFrameRate(60); //设置该对象为不销毁 cc.game.addPersistRootNode(this.node); &#125;, sendMessage(type, parameter) &#123; if (this._connected) &#123; this._socket.emit(type, parameter); &#125; else &#123; cc.warn("未连接服务器"); &#125; &#125;&#125;); 本文参考：https://blog.csdn.net/leovnay/article/details/79272977?utm_source=copy]]></content>
      <categories>
        <category>Cocos Creator</category>
      </categories>
      <tags>
        <tag>Cocos Creator</tag>
        <tag>单例模式</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
