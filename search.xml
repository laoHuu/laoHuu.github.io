<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cocos Creator 全局监听事件]]></title>
    <url>%2F2018%2F09%2F29%2FCocos-Creator-%E5%85%A8%E5%B1%80%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[全局事件系统Cocos Creator中最近要用全局事件派送，奈何官方虽然提供了this.node.emit，但是只能监听同一个节点的事件，不可以实现监听其它节点发出的事件，也就是全局事件，所以自己找了两种方法解决。 cc.EventTarget让所有节点统一在同一个全局对象上触发和监听事件这个全局对象可以是全局节点，也可以是 window.GlobalEvent = new cc.EventTarget(); 1234567891011121314//监听 onLoad() &#123; GlobalEvent.on(&quot;Test&quot;, function (event) &#123; console.log(&quot;Test&quot;, event.detail); &#125;); GlobalEvent.on(&quot;Test&quot;, this.showLog); &#125;, showLog(event) &#123; console.log(&quot;eat&quot;, event.detail); &#125;,//传递事件 GlobalEvent.emit(&quot;Test&quot;, &quot;see you tomorrow&quot;); 插件脚本通过设置一个插件脚本或者全局变量的Notifacation来统一处理事件的监听和分发。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var NOTIFICATION = (function ()&#123; var eventList = &#123;&#125;; function on(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;on&apos; param error!&quot;); return; &#125; if (typeof eventList[type] === &quot;undefined&quot;) &#123; eventList[type] = []; &#125; eventList[type].push(&#123;callback: callback, target: target&#125;); &#125; function once(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;on&apos; param error!&quot;); return; &#125; if (typeof eventList[type] === &quot;undefined&quot;) &#123; eventList[type] = []; &#125; eventList[type].push(&#123;callback: callback, target: target, once: true&#125;); &#125; function emit(type, data) &#123; if (typeof type !== &quot;string&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;emit&apos; param error!&quot;); return; &#125; var list = eventList[type]; if (typeof list !== &quot;undefined&quot;) &#123; for (var i = 0; i &lt; list.length; i++) &#123; var event = list[i]; if (event) &#123; event.callback.call(event.target, data); if(event.once)&#123; off(type, event.callback, event.target); &#125; &#125; &#125; &#125; &#125; function off(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;off&apos; param error!&quot;); return; &#125; var list = eventList[type]; if (typeof list !== &quot;undefined&quot;) &#123; for (var i = 0; i &lt; list.length; i++) &#123; var event = list[i]; if (event &amp;&amp; event.callback === callback &amp;&amp; event.target === target) &#123; list.splice(i, 1); break; &#125; &#125; &#125; &#125; function offByType(type) &#123; if (typeof type !== &quot;string&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;offByType&apos; param error!&quot;); return; &#125; while (eventList[type].length &gt; 1) &#123; eventList[type].shift(); &#125; eventList[type] = undefined; &#125; function offByTarget(target)&#123; if (typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;offByTarget&apos; param error!&quot;); return; &#125; for(var key in eventList)&#123; for(var i = 0; i &lt; eventList[key].length ; i++)&#123; if(eventList[key][i].target === target)&#123; eventList[key].splice(i, 1); cc.log(&apos;off &apos; + key); break; &#125; &#125; &#125; &#125; return &#123;on: on, once: once, emit: emit, off: off, offByType: offByType, offByTarget: offByTarget&#125;;&#125;)();]]></content>
      <tags>
        <tag>Cocos Creator</tag>
        <tag>观察者模式</tag>
        <tag>全局事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator 单例模式]]></title>
    <url>%2F2018%2F09%2F29%2FCocos-Creator-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例，在游戏开发中是比较常用的功能，全局唯一，可以在任何地方直接获取, 省去了方法赋值 或者 属性面板拖动的麻烦。 在Cocos Creator中我用于创建NetwrokManager来控制联网管理，在该单例中处理所有的服务器监听，然后通过观察者模式通知相应的监听事件来处理客户端逻辑。 普通单例 饿汉模式 饱汉模式饿汉模式 不管有没调用，一开始就创建单例 12345678910111213141516171819202122// Singleton.js var Singleton = cc.Class(&#123; // 成员变量 name : "", age : 0, ctor () &#123; this.name = "Leovany"; this.age = 20; &#125;, statics: &#123; _instance: null &#125;, printInfo()&#123; cc.warn("name = " + this.name+",age = " + this.age); &#125;&#125;);Singleton._instance = new Singleton();module.exports = Singleton; 12345678// GameManager.js// 引入单例类var Singleton = require("Singleton");var GameManager = cc.Class(&#123; cc.warn(Singleton._instance.name); Singleton._instance.printInfo();&#125;); 饱汉模式调用时才创建单例对象 1234567891011121314151617181920212223242526// Singleton.js var Singleton = cc.Class(&#123; // 成员变量 name : "", age : 0, ctor () &#123; this.name = "Leovany"; this.age = 20; &#125;, printInfo()&#123; cc.warn("name = " + this.name+",age = " + this.age); &#125;&#125;);Singleton._instance = null;Singleton.getInstance = function () &#123; if(!Singleton._instance)&#123; Singleton._instance = new Singleton(); &#125; return Singleton._instance;&#125;module.exports = Singleton; 12345678// GameManager.js// 引入单例类var Singleton = require("Singleton");var GameManager = cc.Class(&#123; cc.warn(Singleton._instance.name); Singleton._instance.printInfo();&#125;); 单例组件通过创建单例节点，并设置为常驻节点，来保证切换场景时不被摧毁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 开头必须 新建一个变量引用 var NetworkManagervar NetworkManager = cc.Class(&#123; extends: cc.Component, editor: &#123; executionOrder: -1 &#125;, properties: &#123; _userid: 0, _socket: null, _connected: false, DEFAULT_NETWORK_IP: &#123; get() &#123; return "http://123.1.1.1:5000"; &#125;, &#125;, &#125;, statics: &#123; _instance: null &#125;, //最先进入地方 onLoad() &#123; cc.warn(" ============== NetworkManager init"); NetworkManager._instance = this; if (cc.sys.isNative) &#123; window.io = SocketIO; &#125; let self = this; this._socket = window.io(this.DEFAULT_NETWORK_IP); //进行所有数据的监听和存储 this._socket.on('WC_CONNECTED', function (data) &#123; cc.log("now you see WC_CONNECTED"); self._connected = true; &#125;); this._socket.on('WC_LOGIN_RESPONSE', function (data) &#123; // 返回的一些数据 Notification.emit("WC_LOGIN_RESPONSE", data); // 通知客户端监听节点，Notification是一个自己编写的全局的观察者模式。 cc.log("WC_LOGIN_RESPONSE"); cc.log(data); if (data.error_id == 0) &#123; cc.log("login success!"); self.player = data.player; &#125; else &#123; cc.log("login fail!"); &#125; &#125;); //设置帧率 cc.game.setFrameRate(60); //设置该对象为不销毁 cc.game.addPersistRootNode(this.node); &#125;, sendMessage(type, parameter) &#123; if (this._connected) &#123; this._socket.emit(type, parameter); &#125; else &#123; cc.warn("未连接服务器"); &#125; &#125;&#125;); 本文参考：https://blog.csdn.net/leovnay/article/details/79272977?utm_source=copy]]></content>
      <categories>
        <category>Cocos Creator</category>
      </categories>
      <tags>
        <tag>Cocos Creator</tag>
        <tag>单例模式</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
