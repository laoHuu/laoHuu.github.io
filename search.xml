<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MaskField检测选项]]></title>
    <url>%2F2019%2F04%2F02%2FMaskField%E6%A3%80%E6%B5%8B%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[今天在编写工具时发现了一个有趣的Unity方法叫MaskField.但是在查看原文档的时候发现没有如何判断自己选了哪几个选项的方法，所以自己通过试验写了个判定的方法。 MaskField12345678910111213141516171819202122232425262728293031using UnityEngine;using UnityEditor;public class MaskFieldExample : EditorWindow&#123; static int flags = 0; static string[] options = new string[] &#123;&quot;CanJump&quot;, &quot;CanShoot&quot;, &quot;CanSwim&quot;&#125;; [MenuItem(&quot;Examples/Mask Field usage&quot;)] static void Init() &#123; MaskFieldExample window = (MaskFieldExample)GetWindow(typeof(MaskFieldExample)); window.Show(); &#125; void OnGUI() &#123; flags = EditorGUILayout.MaskField(&quot;Player Flags&quot;, flags, options); if (GUILayout.Button(&quot;Log options&quot;)) &#123; for (int i = 0; i &lt; options.Length; i++) &#123; if ((flags &amp; 1 &lt;&lt; i) != 0) &#123; Debug.Log(options[i]); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity世界坐标和本地坐标的转换]]></title>
    <url>%2F2019%2F03%2F14%2FUnity%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[游戏开发过程中，我们经常需要用到本地坐标和世界坐标的转换，尤其是配置位置偏移的时候，例如你希望在某个怪物的左前方放置特效，则需要在怪物的坐标系中做转换。 首先，世界坐标是指物体在场景中的坐标，当某个物体没有父物体时，它的position即为世界坐标的position，rotation同理；本地坐标是物体相对于它的父物体的坐标而言（ 父物体又套父物体的我还没有研究），这个相对坐标是以父物体本身为坐标轴进行计算的，与世界坐标没有必然联系。而对于没有父物体的物体，可以认为不存在本地坐标这种说法。另外有一点需要注意：当某个物体有父物体时，它的inspector栏transform中的position实际是localposition，即本地坐标。 在Unity中提供了很多原生的方法来做坐标转换，所以我们可以直接调用它们的方法来达到我们的目的，所以本文主要为了代码的简化而编写。 Unity原生方法转换 TransformPoint 偏移法TransformPoint 将坐标从本地坐标转到世界坐标,worldPos3为核心用法，将当前本地坐标系中的偏移转到世界坐标系中。 12345678910public Transform myParent; //该物体的父元素// Start is called before the first frame updatevoid Start()&#123; var localPos = transform.localPosition; //本地坐标 var worldPos = transform.position; //transform.position获取到的是世界坐标 var worldPos2 = transform.TransformPoint(Vector3.zero); var worldPos3 = myParent.transform.TransformPoint(localPos); Debug.Log(&quot;localPos:&quot; +localPos+&quot;worldPos:&quot;+worldPos+&quot;worldPos2:&quot;+worldPos2+&quot;worldPos3:&quot;+worldPos3);&#125; 偏移法通过使用四元数乘于偏移的向量来获得旋转后的偏移向量。 1234567public Transform myParent; //该物体的父元素// Start is called before the first frame updatevoid Start()&#123; var localPos = transform.localPosition; //本地坐标 var worldPos4 = myParent.transform.position + myParent.transform.rotation * localPos;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Unity的TreeView来编写一个显示目录和文件的树形菜单]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%A9%E7%94%A8Unity%E7%9A%84TreeView%E6%9D%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[最近在编写unity的工具，碰见需要将工程中某个文件夹下的playable文件遍历出来让人选取，然后再进行操作，所以正好去了解了一下Unity中TreeView的用法，发现真的是很方便，所以做了个方便拓展的专门用于遍历目录文件的TreeView。 你们可以在工程中添加下面两个文件，然后在菜单栏中选中TreeView Examples/File Tree Window就可以查看效果。 FloderFileTreeView.cs首先是TreeView文件FloderFileTreeView.cs，里面包含了继承于TreeViewItem的FolderTreeViewItem，和继承于TreeView的FloderFileTreeView，FolderTreeViewItem中可以添加自己所需要的属性，这样可以在选取的时候做一些操作。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System.Collections.Generic;using System.IO;using UnityEditor.IMGUI.Controls;using UnityEngine;namespace UnityEditor.TreeViewExample&#123; class FloderFileTreeView : TreeView &#123; public FloderFileTreeView(TreeViewState treeViewState) : base(treeViewState) &#123; Reload(); &#125; protected override TreeViewItem BuildRoot () &#123; var root = new TreeViewItem &#123;id = 0, depth = -1, displayName = &quot;Root&quot;&#125;; TraceTree(root,Application.dataPath); return root; &#125; public void TraceTree(TreeViewItem item,string path) &#123; DirectoryInfo theFolder = new DirectoryInfo(path); DirectoryInfo[] dirInfo = theFolder.GetDirectories(); var files = theFolder.GetFiles(&quot;*.*&quot;,SearchOption.TopDirectoryOnly); if (dirInfo.Length &gt; 0) &#123; foreach (DirectoryInfo NextFolder in dirInfo) &#123; FolderTreeViewItem fItem = new FolderTreeViewItem( NextFolder.GetHashCode(), item.depth + 1, NextFolder.Name); item.AddChild(fItem); TraceTree(fItem,path + &quot;/&quot; + NextFolder.Name); &#125; &#125; foreach (var file in files) &#123; FolderTreeViewItem fItem = new FolderTreeViewItem( file.GetHashCode(), item.depth + 1, file.Name); item.AddChild(fItem); &#125; &#125; // protected override void RowGUI (RowGUIArgs args) // &#123; // &#125; protected override void SelectionChanged(IList&lt;int&gt; selectedIds) &#123; base.SelectionChanged(selectedIds); var item = FindItem(selectedIds[0],rootItem) as FolderTreeViewItem; Debug.Log(item.aPath.ToString()); &#125; &#125; public class FolderTreeViewItem : TreeViewItem &#123; public string aPath; public FolderTreeViewItem(int id,int depth,string displayName):base(id,depth,displayName)&#123; aPath = displayName; &#125; &#125;&#125; FloderFileTreeViewWindow.cs窗口用于显示TreeView，其中SearchField用于创建一个搜索框，也是自带的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using UnityEngine;using UnityEditor.IMGUI.Controls;namespace UnityEditor.TreeViewExample&#123; class FloderFileTreeViewWindow : EditorWindow &#123; // We are using SerializeField here to make sure view state is written to the window // layout file. This means that the state survives restarting Unity as long as the window // is not closed. If omitting the attribute then the state just survives assembly reloading // (i.e. it still gets serialized/deserialized) [SerializeField] TreeViewState m_TreeViewState; // The TreeView is not serializable it should be reconstructed from the tree data. FloderFileTreeView m_TreeView; SearchField m_SearchField; void OnEnable () &#123; // Check if we already had a serialized view state (state // that survived assembly reloading) if (m_TreeViewState == null) m_TreeViewState = new TreeViewState (); m_TreeView = new FloderFileTreeView(m_TreeViewState); m_SearchField = new SearchField (); m_SearchField.downOrUpArrowKeyPressed += m_TreeView.SetFocusAndEnsureSelectedItem; &#125; void OnGUI () &#123; DoToolbar (); DoTreeView (); &#125; void DoToolbar() &#123; GUILayout.BeginHorizontal (EditorStyles.toolbar); GUILayout.Space (100); GUILayout.FlexibleSpace(); m_TreeView.searchString = m_SearchField.OnToolbarGUI (m_TreeView.searchString); GUILayout.EndHorizontal(); &#125; void DoTreeView() &#123; var r = EditorGUILayout.GetControlRect(false,303); m_TreeView.OnGUI(r); //m_TreeView.ExpandAll(); &#125; // Add menu named &quot;My Window&quot; to the Window menu [MenuItem (&quot;TreeView Examples/File Tree Window&quot;)] static void ShowWindow () &#123; // Get existing open window or if none, make a new one: var window = GetWindow&lt;FloderFileTreeViewWindow&gt; (); window.titleContent = new GUIContent (&quot;My Window&quot;); window.Show (); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>TreeView</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator 全局监听事件]]></title>
    <url>%2F2018%2F09%2F29%2FCocos-Creator-%E5%85%A8%E5%B1%80%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[全局事件系统Cocos Creator中最近要用全局事件派送，奈何官方虽然提供了this.node.emit，但是只能监听同一个节点的事件，不可以实现监听其它节点发出的事件，也就是全局事件，所以自己找了两种方法解决。 cc.EventTarget让所有节点统一在同一个全局对象上触发和监听事件这个全局对象可以是全局节点，也可以是 window.GlobalEvent = new cc.EventTarget(); 1234567891011121314//监听 onLoad() &#123; GlobalEvent.on(&quot;Test&quot;, function (event) &#123; console.log(&quot;Test&quot;, event.detail); &#125;); GlobalEvent.on(&quot;Test&quot;, this.showLog); &#125;, showLog(event) &#123; console.log(&quot;eat&quot;, event.detail); &#125;,//传递事件 GlobalEvent.emit(&quot;Test&quot;, &quot;see you tomorrow&quot;); 插件脚本通过设置一个插件脚本或者全局变量的Notifacation来统一处理事件的监听和分发。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var NOTIFICATION = (function ()&#123; var eventList = &#123;&#125;; function on(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;on&apos; param error!&quot;); return; &#125; if (typeof eventList[type] === &quot;undefined&quot;) &#123; eventList[type] = []; &#125; eventList[type].push(&#123;callback: callback, target: target&#125;); &#125; function once(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;on&apos; param error!&quot;); return; &#125; if (typeof eventList[type] === &quot;undefined&quot;) &#123; eventList[type] = []; &#125; eventList[type].push(&#123;callback: callback, target: target, once: true&#125;); &#125; function emit(type, data) &#123; if (typeof type !== &quot;string&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;emit&apos; param error!&quot;); return; &#125; var list = eventList[type]; if (typeof list !== &quot;undefined&quot;) &#123; for (var i = 0; i &lt; list.length; i++) &#123; var event = list[i]; if (event) &#123; event.callback.call(event.target, data); if(event.once)&#123; off(type, event.callback, event.target); &#125; &#125; &#125; &#125; &#125; function off(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;off&apos; param error!&quot;); return; &#125; var list = eventList[type]; if (typeof list !== &quot;undefined&quot;) &#123; for (var i = 0; i &lt; list.length; i++) &#123; var event = list[i]; if (event &amp;&amp; event.callback === callback &amp;&amp; event.target === target) &#123; list.splice(i, 1); break; &#125; &#125; &#125; &#125; function offByType(type) &#123; if (typeof type !== &quot;string&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;offByType&apos; param error!&quot;); return; &#125; while (eventList[type].length &gt; 1) &#123; eventList[type].shift(); &#125; eventList[type] = undefined; &#125; function offByTarget(target)&#123; if (typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;offByTarget&apos; param error!&quot;); return; &#125; for(var key in eventList)&#123; for(var i = 0; i &lt; eventList[key].length ; i++)&#123; if(eventList[key][i].target === target)&#123; eventList[key].splice(i, 1); cc.log(&apos;off &apos; + key); break; &#125; &#125; &#125; &#125; return &#123;on: on, once: once, emit: emit, off: off, offByType: offByType, offByTarget: offByTarget&#125;;&#125;)();]]></content>
      <tags>
        <tag>Cocos Creator</tag>
        <tag>观察者模式</tag>
        <tag>全局事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator 单例模式]]></title>
    <url>%2F2018%2F09%2F29%2FCocos-Creator-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例，在游戏开发中是比较常用的功能，全局唯一，可以在任何地方直接获取, 省去了方法赋值 或者 属性面板拖动的麻烦。 在Cocos Creator中我用于创建NetwrokManager来控制联网管理，在该单例中处理所有的服务器监听，然后通过观察者模式通知相应的监听事件来处理客户端逻辑。 普通单例 饿汉模式 饱汉模式饿汉模式 不管有没调用，一开始就创建单例 12345678910111213141516171819202122// Singleton.js var Singleton = cc.Class(&#123; // 成员变量 name : "", age : 0, ctor () &#123; this.name = "Leovany"; this.age = 20; &#125;, statics: &#123; _instance: null &#125;, printInfo()&#123; cc.warn("name = " + this.name+",age = " + this.age); &#125;&#125;);Singleton._instance = new Singleton();module.exports = Singleton; 12345678// GameManager.js// 引入单例类var Singleton = require("Singleton");var GameManager = cc.Class(&#123; cc.warn(Singleton._instance.name); Singleton._instance.printInfo();&#125;); 饱汉模式调用时才创建单例对象 1234567891011121314151617181920212223242526// Singleton.js var Singleton = cc.Class(&#123; // 成员变量 name : "", age : 0, ctor () &#123; this.name = "Leovany"; this.age = 20; &#125;, printInfo()&#123; cc.warn("name = " + this.name+",age = " + this.age); &#125;&#125;);Singleton._instance = null;Singleton.getInstance = function () &#123; if(!Singleton._instance)&#123; Singleton._instance = new Singleton(); &#125; return Singleton._instance;&#125;module.exports = Singleton; 12345678// GameManager.js// 引入单例类var Singleton = require("Singleton");var GameManager = cc.Class(&#123; cc.warn(Singleton._instance.name); Singleton._instance.printInfo();&#125;); 单例组件通过创建单例节点，并设置为常驻节点，来保证切换场景时不被摧毁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 开头必须 新建一个变量引用 var NetworkManagervar NetworkManager = cc.Class(&#123; extends: cc.Component, editor: &#123; executionOrder: -1 &#125;, properties: &#123; _userid: 0, _socket: null, _connected: false, DEFAULT_NETWORK_IP: &#123; get() &#123; return "http://123.1.1.1:5000"; &#125;, &#125;, &#125;, statics: &#123; _instance: null &#125;, //最先进入地方 onLoad() &#123; cc.warn(" ============== NetworkManager init"); NetworkManager._instance = this; if (cc.sys.isNative) &#123; window.io = SocketIO; &#125; let self = this; this._socket = window.io(this.DEFAULT_NETWORK_IP); //进行所有数据的监听和存储 this._socket.on('WC_CONNECTED', function (data) &#123; cc.log("now you see WC_CONNECTED"); self._connected = true; &#125;); this._socket.on('WC_LOGIN_RESPONSE', function (data) &#123; // 返回的一些数据 Notification.emit("WC_LOGIN_RESPONSE", data); // 通知客户端监听节点，Notification是一个自己编写的全局的观察者模式。 cc.log("WC_LOGIN_RESPONSE"); cc.log(data); if (data.error_id == 0) &#123; cc.log("login success!"); self.player = data.player; &#125; else &#123; cc.log("login fail!"); &#125; &#125;); //设置帧率 cc.game.setFrameRate(60); //设置该对象为不销毁 cc.game.addPersistRootNode(this.node); &#125;, sendMessage(type, parameter) &#123; if (this._connected) &#123; this._socket.emit(type, parameter); &#125; else &#123; cc.warn("未连接服务器"); &#125; &#125;&#125;); 本文参考：https://blog.csdn.net/leovnay/article/details/79272977?utm_source=copy]]></content>
      <categories>
        <category>Cocos Creator</category>
      </categories>
      <tags>
        <tag>Cocos Creator</tag>
        <tag>单例模式</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
