<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AssetBundle入门解析]]></title>
    <url>%2F2019%2F04%2F08%2FAssetBundle%E5%85%A5%E9%97%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一个开头快速功能迭代开发的游戏，直到中后期才萌生热更新的需求，而在Unity里做资源热更（AssetBundle）和代码热更（Lua）是一个不小的工作，需要耗费相当多的精力。怎么办？。 相信大家对于游戏的热更新都有了一定的概念，但是AssetBundle究竟是什么东西？和Resource的加载方式有什么不一样呢？ 介绍AssetBundles是Unity编辑器中在编辑过程中创建的一些文件，这些文件可以在项目运行环境中使用。AssetBundles可以包含的资源文件比如模型，材质，贴图和场景等等，注意：AssetBundles不能包含脚本! 具体来说，一个AssetBundle就是把资源或者场景以某种方式紧密集合在一起的一个文件。这个AssetBundle文件可以被单独加载到unity应用程序中。这允许模型、贴图、音效设置很大的场景这些资源进行流式加载或者异步加载。当然AssetBundle文件也可以本地缓存这样能够在程序启动的时候立马被加载出来。但AssetBundle技术主要目的就是需要的时候从远程服务器下载需要的资源。AssetBundle可以包含任何unity可识别的资源文件，甚至包括二进制文件。但就是不能包含脚本文件。 在Resource模式中，开发者是几乎完全不用操心他们的资源管理的技术细节。直接使用编辑器进行资源编辑，用完以后开发完以后直接打包最终程序就可以了。而Asset Bundle模式则需要自己进行资源的打包加载管理。在AssetBundle模式和Resource相比较之下，这个模式看上去就像后来迭代版本的时候加出来的一个功能——基于原有Resource模式的不足，提供一个对资源方式更自由控制的方式。 AssetBundle允许从本地或者远程服务器加载Assets资源，利用AssetBundle技术，Assets资源可以放在远程服务器上，这种技术增加了项目灵活性并且减少项目初始包的大小。 本文介绍AssetBundles并且讨论一步一步的介绍怎么样使用它，怎样将资源打包到AssetBundle中，如何通过AssetBundle来加载资源到游戏中。 AssetBundle资源打包创建工程和资源首先我们创建一个新工程并在里面创建出一个Material和Prefab资源，让Prefab资源引用Material。整个项目的结构如图： 编写脚本在Unity中打AssetBundle包很简单，只需要调用 BuildPipeline.BuildAssetBundles 方法就好了，但是要为想要导出的资源设置好 assetBundleName ，如果该资源没有被设置 assetBundleName，而且没有被设置了 assetBundleName 的资源所引用，那么Unity就不会打包该资源。那么如何在项目中设置 assetBundleName 呢？ 首先在Project目录中选中想要导出的资源，在Inspector的最底下有个展示框，如果没有的话点住图中的label往上拉就可以看见了，如图中的前一格就是我们的 assetBundleName ，后面一格是我们的Asset Bundle Variant，目前不做介绍，先不设置，我们按图中的设置把Material和Prefab都设置assetBundleName为test。 BuildPipeline.BuildAssetBundles 有两种重载，我将会在代码中介绍他们的区别。创建BuildAssetBundlesExample，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Create an AssetBundle for Windows.using UnityEngine;using UnityEditor;using System.IO;#if UNITY_EDITOR //若脚本文件不在Editor目录下，则需要判断，否则会报错public class BuildAssetBundlesExample : MonoBehaviour&#123; [MenuItem(&quot;Example/Build Asset Bundle&quot;)] static void BuildABs() &#123; var path = &quot;Assets/ABs&quot;; Debug.Log(&quot;启动所有的打包&quot;); //简易打包法，将当前项目中所有设置了assetBundleName 的或者被引用的资源都打包到对应路径。 // BuildTarget用来控制对应的平台，每个平台的assetbundle不能通用，所以每个平台的包都要重新打，这边为了方便在电脑上测试我们设置成StandaloneWindows。 //BuildAssetBundleOptions控制压缩，主要是三种，None默认使用LZMA //1.LZMA : 压缩厉害，但是每次访问都要全部解压，比如我只需要访问该assetbundle的某个prefab，但是却需要等整个assetbundle的资源解压完毕，访问速度慢。 //2.LZ4 ： 压缩比LZMA差一点，但是只需要解压我们需要访问的资源，访问速度比LZMA快。 //3. 不压缩。 // Put the bundles in a folder called &quot;ABs&quot; within the Assets folder. if (!Directory.Exists(path)) &#123; Directory.CreateDirectory(path); &#125; BuildPipeline.BuildAssetBundles(path, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows); &#125; [MenuItem(&quot;Example/Build Asset Bundles Using BuildMap&quot;)] static void BuildMapABs() &#123; //像第一种，我们必须要给每个资源精细设置assetBundleName，然而在整个项目很大的情况下，你肯定希望用脚本来控制这一些资源，这时候就可以使用第二种重载的方式 // Create the array of bundle build details. AssetBundleBuild[] buildMap = new AssetBundleBuild[2]; buildMap[0].assetBundleName = &quot;prefabbundle&quot;; string[] prefabAssets = new string[2]; prefabAssets[0] = &quot;Assets/Prefabs/Cube.prefab&quot;; buildMap[0].assetNames = prefabAssets; buildMap[1].assetBundleName = &quot;materialbundle&quot;; string[] materialAssets = new string[1]; materialAssets[0] = &quot;Assets/Materials/New Material.mat&quot;; buildMap[1].assetNames = materialAssets; var path = &quot;Assets/ABsBuildMap&quot;; // Put the bundles in a folder called &quot;ABs&quot; within the Assets folder. if (!Directory.Exists(path)) &#123; Directory.CreateDirectory(path); &#125; BuildPipeline.BuildAssetBundles(path, buildMap, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows); &#125;&#125;#endif 当你创建了这个脚本后，你就可以通过项目中的Example下的选项来使用两种方法导出项目的资源了。 导出的资源分析我们查看下第一种方式打包出来的assetbundle的资源。可以看到我们在Assets/ABs下有了四个文件。 我们可以注意到目录下有两个和文件夹名字一样的文件，打开ABs.manifest查看下信息。 12345678// ABs.manifestManifestFileVersion: 0CRC: 3628773453AssetBundleManifest: AssetBundleInfos: Info_0: Name: test Dependencies: &#123;&#125; 该文件为整个目录下的所有assetbundle的记录，它记录了每个assetbundle间的依赖情况和整个文件夹下的所有的assetbundle的信息，我们后面可以通过它来查找所需要加载的依赖。 1234567891011121314151617181920212223242526272829303132// test.manifestManifestFileVersion: 0CRC: 1635728007Hashes: AssetFileHash: serializedVersion: 2 Hash: 48e66a94b791e3c542d971998c32fe2d TypeTreeHash: serializedVersion: 2 Hash: ea3f786f3814b1ad9ef2ef747825eec5HashAppended: 0ClassTypes:- Class: 1 Script: &#123;instanceID: 0&#125;- Class: 4 Script: &#123;instanceID: 0&#125;- Class: 21 Script: &#123;instanceID: 0&#125;- Class: 23 Script: &#123;instanceID: 0&#125;- Class: 33 Script: &#123;instanceID: 0&#125;- Class: 43 Script: &#123;instanceID: 0&#125;- Class: 48 Script: &#123;instanceID: 0&#125;- Class: 65 Script: &#123;instanceID: 0&#125;Assets:- Assets/Prefabs/Cube.prefab- Assets/Materials/New Material.matDependencies: [] test.manifest下记录了该assetbundle下的所有asset和该assetbundle的依赖情况 加载资源资源都在一个 assetbundle比如第一种打包情况，我们将prefab和它所依赖的material都打包到test这个AssetBundle中，那么我们加载的时候就只需要加载这个assetbundle就好了，加载方式如下： 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class LoadAssetBundle : MonoBehaviour&#123; // Start is called before the first frame update void Start() &#123; //从test包中加载 AssetBundle prefabAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABs&quot;, &quot;test&quot;)); if (prefabAssetBundle == null) &#123; Debug.Log(&quot;Failed to load AssetBundle!&quot;); return; &#125; var prefab = prefabAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); Instantiate(prefab); prefabAssetBundle.Unload(false); //释放掉assetbundle，false表示释放掉prefabAssetBundle但是不回收场景里面的对应的资源，那么留在场景里的资源就要自己手动释放。true表示释放掉prefabAssetBundle并回收场景里面的对应的资源，一般在切换场景之类的时候使用，要小心使用。 ｝｝ 资源都不在同一个 assetbundle第二种打包情况中我们把prefab分到了prefabbundle这个包中，然后它所引用的material则分到了materialbundle包中，所以我们加载的时候需要加载两个包。 12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class LoadAssetBundle : MonoBehaviour&#123; // Start is called before the first frame update void Start() &#123; //当material和prefab分开在不同的包中加载 //如果不加载materialbundle，实例化出来的prefab会丢失材质 var matAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, &quot;materialbundle&quot;)); var prefabAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, &quot;prefabbundle&quot;)); if (prefabAssetBundle == null) &#123; Debug.Log(&quot;Failed to load prefabAssetBundle!&quot;); return; &#125; if (matAssetBundle == null) &#123; Debug.Log(&quot;Failed to load matAssetBundle!&quot;); return; &#125; var prefab2 = prefabAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); Instantiate(prefab2); prefabAssetBundle.Unload(false); matAssetBundle.Unload(false); ｝｝ 我们也可以通过包的主文件来动态查询我们的依赖包的包名，并进行加载，代码如下： 12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class LoadAssetBundle : MonoBehaviour&#123; // Start is called before the first frame update void Start() &#123; //当material和prefab分开在不同的包中加载,通过包查找依赖 //加载主要的AssetBundleManifest AssetBundle mainAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, &quot;ABsBuildMap&quot;)); AssetBundleManifest manifest = mainAssetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;); var prefabAssetBundle = AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, &quot;prefabbundle&quot;)); //foreach (var name in manifest.GetAllAssetBundles()) //遍历所有的AssetBundle的名字 //&#123; // print(name); //&#125; var dependsAssetBundle = new List&lt;AssetBundle&gt;(manifest.GetAllDependencies(&quot;prefabbundle&quot;).Length); foreach (var name in manifest.GetAllDependencies(&quot;prefabbundle&quot;)) //遍历prefabbundle包所有的依赖的AssetBundle的名字 &#123; dependsAssetBundle.Add(AssetBundle.LoadFromFile(Path.Combine(&quot;Assets/ABsBuildMap&quot;, name))); //加载所有的依赖包 &#125; var prefab2 = prefabAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); Instantiate(prefab2); ｝｝ 加载服务器上的assetbundle热更新中我们一般会把assetbundle部署到服务器上，Unity为我们封装了UnityWebRequest来加载。 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class LoadAssetBundle : MonoBehaviour&#123; // Start is called before the first frame update IEnumerator Start() &#123; //--------- string url = @&quot;file:///E:\UnityProject\AssetBundleTest\Assets\ABs\test&quot;; //假设为服务端地址 UnityWebRequest uwr = UnityWebRequestAssetBundle.GetAssetBundle(url); yield return uwr.SendWebRequest(); //Get an asset from the bundle and instantiate it. AssetBundle myLoadedAssetBundle = DownloadHandlerAssetBundle.GetContent(uwr); var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Assets/Prefabs/Cube.prefab&quot;); //var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;); Instantiate(prefab); myLoadedAssetBundle.Unload(false); ｝｝ 以上就是主要的入门知识了，大家可以发现整个AssetBundle目前的方法其实是不全的，想要做到热更新的话我们还需要版本对比，然后我们最好能够手写一个资源回收方法来控制AssetBundle的Unload操作，这些我会放在下一章开始讲，当然Unity本身也有很多其它的可以异步的加载方式，比如LoadFromMemoryAsync之类的，大体都一样，可以自己去查看官方文档。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaskField检测选项]]></title>
    <url>%2F2019%2F04%2F02%2FMaskField%E6%A3%80%E6%B5%8B%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[今天在编写工具时发现了一个有趣的Unity方法叫MaskField.但是在查看原文档的时候发现没有如何判断自己选了哪几个选项的方法，所以自己通过试验写了个判定的方法。 MaskField12345678910111213141516171819202122232425262728293031using UnityEngine;using UnityEditor;public class MaskFieldExample : EditorWindow&#123; static int flags = 0; static string[] options = new string[] &#123;&quot;CanJump&quot;, &quot;CanShoot&quot;, &quot;CanSwim&quot;&#125;; [MenuItem(&quot;Examples/Mask Field usage&quot;)] static void Init() &#123; MaskFieldExample window = (MaskFieldExample)GetWindow(typeof(MaskFieldExample)); window.Show(); &#125; void OnGUI() &#123; flags = EditorGUILayout.MaskField(&quot;Player Flags&quot;, flags, options); if (GUILayout.Button(&quot;Log options&quot;)) &#123; for (int i = 0; i &lt; options.Length; i++) &#123; if ((flags &amp; 1 &lt;&lt; i) != 0) &#123; Debug.Log(options[i]); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity世界坐标和本地坐标的转换]]></title>
    <url>%2F2019%2F03%2F14%2FUnity%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[游戏开发过程中，我们经常需要用到本地坐标和世界坐标的转换，尤其是配置位置偏移的时候，例如你希望在某个怪物的左前方放置特效，则需要在怪物的坐标系中做转换。 首先，世界坐标是指物体在场景中的坐标，当某个物体没有父物体时，它的position即为世界坐标的position，rotation同理；本地坐标是物体相对于它的父物体的坐标而言（ 父物体又套父物体的我还没有研究），这个相对坐标是以父物体本身为坐标轴进行计算的，与世界坐标没有必然联系。而对于没有父物体的物体，可以认为不存在本地坐标这种说法。另外有一点需要注意：当某个物体有父物体时，它的inspector栏transform中的position实际是localposition，即本地坐标。 在Unity中提供了很多原生的方法来做坐标转换，所以我们可以直接调用它们的方法来达到我们的目的，所以本文主要为了代码的简化而编写。 Unity原生方法转换 TransformPoint 偏移法TransformPoint 将坐标从本地坐标转到世界坐标,worldPos3为核心用法，将当前本地坐标系中的偏移转到世界坐标系中。 12345678910public Transform myParent; //该物体的父元素// Start is called before the first frame updatevoid Start()&#123; var localPos = transform.localPosition; //本地坐标 var worldPos = transform.position; //transform.position获取到的是世界坐标 var worldPos2 = transform.TransformPoint(Vector3.zero); var worldPos3 = myParent.transform.TransformPoint(localPos); Debug.Log(&quot;localPos:&quot; +localPos+&quot;worldPos:&quot;+worldPos+&quot;worldPos2:&quot;+worldPos2+&quot;worldPos3:&quot;+worldPos3);&#125; 偏移法通过使用四元数乘于偏移的向量来获得旋转后的偏移向量。 1234567public Transform myParent; //该物体的父元素// Start is called before the first frame updatevoid Start()&#123; var localPos = transform.localPosition; //本地坐标 var worldPos4 = myParent.transform.position + myParent.transform.rotation * localPos;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Unity的TreeView来编写一个显示目录和文件的树形菜单]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%A9%E7%94%A8Unity%E7%9A%84TreeView%E6%9D%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[最近在编写unity的工具，碰见需要将工程中某个文件夹下的playable文件遍历出来让人选取，然后再进行操作，所以正好去了解了一下Unity中TreeView的用法，发现真的是很方便，所以做了个方便拓展的专门用于遍历目录文件的TreeView。 你们可以在工程中添加下面两个文件，然后在菜单栏中选中TreeView Examples/File Tree Window就可以查看效果。 FloderFileTreeView.cs首先是TreeView文件FloderFileTreeView.cs，里面包含了继承于TreeViewItem的FolderTreeViewItem，和继承于TreeView的FloderFileTreeView，FolderTreeViewItem中可以添加自己所需要的属性，这样可以在选取的时候做一些操作。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System.Collections.Generic;using System.IO;using UnityEditor.IMGUI.Controls;using UnityEngine;namespace UnityEditor.TreeViewExample&#123; class FloderFileTreeView : TreeView &#123; public FloderFileTreeView(TreeViewState treeViewState) : base(treeViewState) &#123; Reload(); &#125; protected override TreeViewItem BuildRoot () &#123; var root = new TreeViewItem &#123;id = 0, depth = -1, displayName = &quot;Root&quot;&#125;; TraceTree(root,Application.dataPath); return root; &#125; public void TraceTree(TreeViewItem item,string path) &#123; DirectoryInfo theFolder = new DirectoryInfo(path); DirectoryInfo[] dirInfo = theFolder.GetDirectories(); var files = theFolder.GetFiles(&quot;*.*&quot;,SearchOption.TopDirectoryOnly); if (dirInfo.Length &gt; 0) &#123; foreach (DirectoryInfo NextFolder in dirInfo) &#123; FolderTreeViewItem fItem = new FolderTreeViewItem( NextFolder.GetHashCode(), item.depth + 1, NextFolder.Name); item.AddChild(fItem); TraceTree(fItem,path + &quot;/&quot; + NextFolder.Name); &#125; &#125; foreach (var file in files) &#123; FolderTreeViewItem fItem = new FolderTreeViewItem( file.GetHashCode(), item.depth + 1, file.Name); item.AddChild(fItem); &#125; &#125; // protected override void RowGUI (RowGUIArgs args) // &#123; // &#125; protected override void SelectionChanged(IList&lt;int&gt; selectedIds) &#123; base.SelectionChanged(selectedIds); var item = FindItem(selectedIds[0],rootItem) as FolderTreeViewItem; Debug.Log(item.aPath.ToString()); &#125; &#125; public class FolderTreeViewItem : TreeViewItem &#123; public string aPath; public FolderTreeViewItem(int id,int depth,string displayName):base(id,depth,displayName)&#123; aPath = displayName; &#125; &#125;&#125; FloderFileTreeViewWindow.cs窗口用于显示TreeView，其中SearchField用于创建一个搜索框，也是自带的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using UnityEngine;using UnityEditor.IMGUI.Controls;namespace UnityEditor.TreeViewExample&#123; class FloderFileTreeViewWindow : EditorWindow &#123; // We are using SerializeField here to make sure view state is written to the window // layout file. This means that the state survives restarting Unity as long as the window // is not closed. If omitting the attribute then the state just survives assembly reloading // (i.e. it still gets serialized/deserialized) [SerializeField] TreeViewState m_TreeViewState; // The TreeView is not serializable it should be reconstructed from the tree data. FloderFileTreeView m_TreeView; SearchField m_SearchField; void OnEnable () &#123; // Check if we already had a serialized view state (state // that survived assembly reloading) if (m_TreeViewState == null) m_TreeViewState = new TreeViewState (); m_TreeView = new FloderFileTreeView(m_TreeViewState); m_SearchField = new SearchField (); m_SearchField.downOrUpArrowKeyPressed += m_TreeView.SetFocusAndEnsureSelectedItem; &#125; void OnGUI () &#123; DoToolbar (); DoTreeView (); &#125; void DoToolbar() &#123; GUILayout.BeginHorizontal (EditorStyles.toolbar); GUILayout.Space (100); GUILayout.FlexibleSpace(); m_TreeView.searchString = m_SearchField.OnToolbarGUI (m_TreeView.searchString); GUILayout.EndHorizontal(); &#125; void DoTreeView() &#123; var r = EditorGUILayout.GetControlRect(false,303); m_TreeView.OnGUI(r); //m_TreeView.ExpandAll(); &#125; // Add menu named &quot;My Window&quot; to the Window menu [MenuItem (&quot;TreeView Examples/File Tree Window&quot;)] static void ShowWindow () &#123; // Get existing open window or if none, make a new one: var window = GetWindow&lt;FloderFileTreeViewWindow&gt; (); window.titleContent = new GUIContent (&quot;My Window&quot;); window.Show (); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>TreeView</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator 全局监听事件]]></title>
    <url>%2F2018%2F09%2F29%2FCocos-Creator-%E5%85%A8%E5%B1%80%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[全局事件系统Cocos Creator中最近要用全局事件派送，奈何官方虽然提供了this.node.emit，但是只能监听同一个节点的事件，不可以实现监听其它节点发出的事件，也就是全局事件，所以自己找了两种方法解决。 cc.EventTarget让所有节点统一在同一个全局对象上触发和监听事件这个全局对象可以是全局节点，也可以是 window.GlobalEvent = new cc.EventTarget(); 1234567891011121314//监听 onLoad() &#123; GlobalEvent.on(&quot;Test&quot;, function (event) &#123; console.log(&quot;Test&quot;, event.detail); &#125;); GlobalEvent.on(&quot;Test&quot;, this.showLog); &#125;, showLog(event) &#123; console.log(&quot;eat&quot;, event.detail); &#125;,//传递事件 GlobalEvent.emit(&quot;Test&quot;, &quot;see you tomorrow&quot;); 插件脚本通过设置一个插件脚本或者全局变量的Notifacation来统一处理事件的监听和分发。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var NOTIFICATION = (function ()&#123; var eventList = &#123;&#125;; function on(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;on&apos; param error!&quot;); return; &#125; if (typeof eventList[type] === &quot;undefined&quot;) &#123; eventList[type] = []; &#125; eventList[type].push(&#123;callback: callback, target: target&#125;); &#125; function once(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;on&apos; param error!&quot;); return; &#125; if (typeof eventList[type] === &quot;undefined&quot;) &#123; eventList[type] = []; &#125; eventList[type].push(&#123;callback: callback, target: target, once: true&#125;); &#125; function emit(type, data) &#123; if (typeof type !== &quot;string&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;emit&apos; param error!&quot;); return; &#125; var list = eventList[type]; if (typeof list !== &quot;undefined&quot;) &#123; for (var i = 0; i &lt; list.length; i++) &#123; var event = list[i]; if (event) &#123; event.callback.call(event.target, data); if(event.once)&#123; off(type, event.callback, event.target); &#125; &#125; &#125; &#125; &#125; function off(type, callback, target) &#123; if (typeof type !== &quot;string&quot; || typeof callback !== &quot;function&quot; || typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;off&apos; param error!&quot;); return; &#125; var list = eventList[type]; if (typeof list !== &quot;undefined&quot;) &#123; for (var i = 0; i &lt; list.length; i++) &#123; var event = list[i]; if (event &amp;&amp; event.callback === callback &amp;&amp; event.target === target) &#123; list.splice(i, 1); break; &#125; &#125; &#125; &#125; function offByType(type) &#123; if (typeof type !== &quot;string&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;offByType&apos; param error!&quot;); return; &#125; while (eventList[type].length &gt; 1) &#123; eventList[type].shift(); &#125; eventList[type] = undefined; &#125; function offByTarget(target)&#123; if (typeof target === &quot;undefined&quot;) &#123; cc.error(&quot;GLOBAL_DEF.js: NOTIFICATION method &apos;offByTarget&apos; param error!&quot;); return; &#125; for(var key in eventList)&#123; for(var i = 0; i &lt; eventList[key].length ; i++)&#123; if(eventList[key][i].target === target)&#123; eventList[key].splice(i, 1); cc.log(&apos;off &apos; + key); break; &#125; &#125; &#125; &#125; return &#123;on: on, once: once, emit: emit, off: off, offByType: offByType, offByTarget: offByTarget&#125;;&#125;)();]]></content>
      <tags>
        <tag>Cocos Creator</tag>
        <tag>观察者模式</tag>
        <tag>全局事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocos Creator 单例模式]]></title>
    <url>%2F2018%2F09%2F29%2FCocos-Creator-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例，在游戏开发中是比较常用的功能，全局唯一，可以在任何地方直接获取, 省去了方法赋值 或者 属性面板拖动的麻烦。 在Cocos Creator中我用于创建NetwrokManager来控制联网管理，在该单例中处理所有的服务器监听，然后通过观察者模式通知相应的监听事件来处理客户端逻辑。 普通单例 饿汉模式 饱汉模式饿汉模式 不管有没调用，一开始就创建单例 12345678910111213141516171819202122// Singleton.js var Singleton = cc.Class(&#123; // 成员变量 name : "", age : 0, ctor () &#123; this.name = "Leovany"; this.age = 20; &#125;, statics: &#123; _instance: null &#125;, printInfo()&#123; cc.warn("name = " + this.name+",age = " + this.age); &#125;&#125;);Singleton._instance = new Singleton();module.exports = Singleton; 12345678// GameManager.js// 引入单例类var Singleton = require("Singleton");var GameManager = cc.Class(&#123; cc.warn(Singleton._instance.name); Singleton._instance.printInfo();&#125;); 饱汉模式调用时才创建单例对象 1234567891011121314151617181920212223242526// Singleton.js var Singleton = cc.Class(&#123; // 成员变量 name : "", age : 0, ctor () &#123; this.name = "Leovany"; this.age = 20; &#125;, printInfo()&#123; cc.warn("name = " + this.name+",age = " + this.age); &#125;&#125;);Singleton._instance = null;Singleton.getInstance = function () &#123; if(!Singleton._instance)&#123; Singleton._instance = new Singleton(); &#125; return Singleton._instance;&#125;module.exports = Singleton; 12345678// GameManager.js// 引入单例类var Singleton = require("Singleton");var GameManager = cc.Class(&#123; cc.warn(Singleton._instance.name); Singleton._instance.printInfo();&#125;); 单例组件通过创建单例节点，并设置为常驻节点，来保证切换场景时不被摧毁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 开头必须 新建一个变量引用 var NetworkManagervar NetworkManager = cc.Class(&#123; extends: cc.Component, editor: &#123; executionOrder: -1 &#125;, properties: &#123; _userid: 0, _socket: null, _connected: false, DEFAULT_NETWORK_IP: &#123; get() &#123; return "http://123.1.1.1:5000"; &#125;, &#125;, &#125;, statics: &#123; _instance: null &#125;, //最先进入地方 onLoad() &#123; cc.warn(" ============== NetworkManager init"); NetworkManager._instance = this; if (cc.sys.isNative) &#123; window.io = SocketIO; &#125; let self = this; this._socket = window.io(this.DEFAULT_NETWORK_IP); //进行所有数据的监听和存储 this._socket.on('WC_CONNECTED', function (data) &#123; cc.log("now you see WC_CONNECTED"); self._connected = true; &#125;); this._socket.on('WC_LOGIN_RESPONSE', function (data) &#123; // 返回的一些数据 Notification.emit("WC_LOGIN_RESPONSE", data); // 通知客户端监听节点，Notification是一个自己编写的全局的观察者模式。 cc.log("WC_LOGIN_RESPONSE"); cc.log(data); if (data.error_id == 0) &#123; cc.log("login success!"); self.player = data.player; &#125; else &#123; cc.log("login fail!"); &#125; &#125;); //设置帧率 cc.game.setFrameRate(60); //设置该对象为不销毁 cc.game.addPersistRootNode(this.node); &#125;, sendMessage(type, parameter) &#123; if (this._connected) &#123; this._socket.emit(type, parameter); &#125; else &#123; cc.warn("未连接服务器"); &#125; &#125;&#125;); 本文参考：https://blog.csdn.net/leovnay/article/details/79272977?utm_source=copy]]></content>
      <categories>
        <category>Cocos Creator</category>
      </categories>
      <tags>
        <tag>Cocos Creator</tag>
        <tag>单例模式</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
